{"version":3,"file":"carousel.stories-328e7338.js","sources":["../../src/components/ebay-carousel/utils/on-scroll-debounced/index.js","../../src/components/ebay-carousel/utils/on-scroll-end/index.js","../../src/components/ebay-carousel/utils/scroll-transition/index.js","../../src/components/ebay-carousel/component.js","../../src/components/ebay-carousel/index.marko","../../src/components/ebay-carousel/README.md","../../src/components/ebay-carousel/examples/preserve-tabindex.marko","../../src/components/ebay-carousel/examples/preserve-tabindex.marko?raw"],"sourcesContent":["const eventOptions = { passive: true };\n\nexport function onScrollDebounced(el, cb) {\n    let timeout;\n    waitForScroll();\n    return cancel;\n\n    function waitForScroll() {\n        el.addEventListener(\"scroll\", handleScroll, eventOptions);\n    }\n\n    function handleScroll() {\n        cancelWaitForScroll();\n        timeout = setTimeout(finish, 640);\n    }\n\n    function finish() {\n        cb();\n        waitForScroll();\n    }\n\n    function cancelWaitForScroll() {\n        el.removeEventListener(\"scroll\", handleScroll, eventOptions);\n    }\n\n    function cancel() {\n        cancelWaitForScroll();\n        clearTimeout(timeout);\n    }\n}\n","/**\n * Checks on an interval to see if the element is scrolling.\n * When the scrolling has finished it then calls the function.\n *\n * @param {HTMLElement} el The element which scrolls.\n * @param {(offset: number)=>{}} fn The function to call after scrolling completes.\n * @return {function} A function to cancel the scroll listener.\n */\nexport function onScrollEnd(el, fn) {\n    let timeout;\n    let frame;\n    let lastPos;\n\n    (function checkMoved() {\n        const { scrollLeft } = el;\n        if (lastPos !== scrollLeft) {\n            lastPos = scrollLeft;\n            timeout = setTimeout(() => {\n                frame = requestAnimationFrame(checkMoved);\n            }, 90);\n            return;\n        }\n\n        fn(lastPos);\n    })();\n\n    return () => {\n        clearTimeout(timeout);\n        cancelAnimationFrame(frame);\n    };\n}\n","import { onScrollEnd } from \"../on-scroll-end\";\nconst supportsScrollBehavior =\n    typeof window !== \"undefined\" &&\n    \"scrollBehavior\" in document.documentElement.style;\n/**\n * Utility to animate scroll position of an element using an `ease-out` curve over 250ms.\n * Cancels the animation if the user touches back down.\n *\n * @param {HTMLElement} el The element to scroll.\n * @param {number} to The offset to animate to.\n * @param {function} fn A function that will be called after the transition completes.\n * @return {function} A function that cancels the transition.\n */\nexport function scrollTransition(el, to, fn) {\n    if (supportsScrollBehavior) {\n        el.scrollTo({ left: to });\n        return onScrollEnd(el, fn);\n    }\n\n    let lastPosition, cancelInterruptTransition;\n    let frame = requestAnimationFrame((startTime) => {\n        const { scrollLeft } = el;\n        const distance = to - scrollLeft;\n        const duration = 450;\n        (function animate(curTime) {\n            const delta = curTime - startTime;\n            if (delta > duration) {\n                el.scrollLeft = to;\n                cancel();\n                return fn();\n            }\n\n            el.scrollLeft = easeInOut(delta / duration) * distance + scrollLeft;\n            frame = requestAnimationFrame(animate);\n        })(startTime);\n    });\n\n    // The animation can be interrupted by new touch events.\n    el.addEventListener(\"touchstart\", handleTouchStart);\n\n    return cancel;\n\n    function cancel() {\n        cancelAnimationFrame(frame);\n\n        if (lastPosition === undefined) {\n            cancelTouchStart();\n        } else {\n            if (cancelInterruptTransition) cancelInterruptTransition();\n            cancelTouchEnd();\n        }\n    }\n\n    function handleTouchStart() {\n        cancel();\n        lastPosition = el.scrollLeft;\n        // If we were interrupted by a touch start we wait for a touch end to see if we moved.\n        el.addEventListener(\"touchend\", handleTouchEnd);\n    }\n\n    function handleTouchEnd() {\n        cancelTouchEnd();\n        // If we haven't moved because of the interrupt we continue to transition.\n        if (lastPosition === el.scrollLeft) {\n            cancelInterruptTransition = scrollTransition(el, to, fn);\n        }\n    }\n\n    function cancelTouchStart() {\n        el.removeEventListener(\"touchstart\", handleTouchStart);\n    }\n\n    function cancelTouchEnd() {\n        el.removeEventListener(\"touchend\", handleTouchEnd);\n    }\n}\n\n/**\n * Ease out timing function.\n * Based on https://gist.github.com/gre/1650294.\n *\n * @param {number} val - A number between 0 and 1.\n * @return {number}\n */\nfunction easeInOut(v) {\n    return v < 0.5 ? 2 * v * v : -1 + (4 - 2 * v) * v;\n}\n","import focusables from \"makeup-focusables\";\n// TODO check carousel\nimport { resizeUtil } from \"../../common/event-utils\";\nimport { processHtmlAttributes } from \"../../common/html-attributes\";\nimport { onScrollDebounced as onScroll } from \"./utils/on-scroll-debounced\";\nimport { scrollTransition } from \"./utils/scroll-transition\";\n\n// Used for carousel slide direction.\nconst LEFT = -1;\nconst RIGHT = 1;\n\nfunction getTemplateData(state) {\n    const { config, autoplayInterval, items, itemsPerSlide, slideWidth, gap } =\n        state;\n    const hasOverride = config.offsetOverride !== undefined;\n    const isSingleSlide = items.length <= itemsPerSlide;\n    state.index = normalizeIndex(state, state.index);\n\n    const offset = getOffset(state);\n    const prevControlDisabled =\n        isSingleSlide || (!autoplayInterval && offset === 0);\n    const nextControlDisabled =\n        isSingleSlide || (!autoplayInterval && offset === getMaxOffset(state));\n    // If left/right is undefined, the carousel is moving at that moment. We should keep the old disabled state\n    const bothControlsDisabled = isAnimating(state)\n        ? state.bothControlsDisabled\n        : prevControlDisabled && nextControlDisabled;\n    let slide, itemWidth, totalSlides;\n\n    if (itemsPerSlide) {\n        const itemsInSlide = itemsPerSlide + state.peek;\n        slide = getSlide(state);\n        itemWidth = `calc(${100 / itemsInSlide}% - ${\n            ((itemsInSlide - 1) * gap) / itemsInSlide\n        }px)`;\n        totalSlides = getSlide(state, items.length);\n    }\n\n    items.forEach((item, i) => {\n        const { style, transform } = item;\n        const marginRight = i !== items.length - 1 && `${gap}px`;\n\n        // Account for users providing a style string or object for each item.\n        if (typeof style === \"string\") {\n            item.style = `${style};flex-basis:${itemWidth};margin-right:${marginRight};`;\n            if (transform) item.style += `transform:${transform}`;\n        } else {\n            item.style = Object.assign({}, style, {\n                width: itemWidth,\n                \"margin-right\": marginRight,\n                transform,\n            });\n        }\n\n        item.fullyVisible =\n            item.left === undefined ||\n            (item.left - offset >= -0.01 &&\n                item.right - offset <= slideWidth + 0.01);\n    });\n\n    const data = Object.assign({}, state, {\n        items,\n        slide,\n        offset: hasOverride ? config.offsetOverride : offset,\n        disableTransition: hasOverride,\n        totalSlides,\n        prevControlDisabled,\n        nextControlDisabled,\n        bothControlsDisabled,\n    });\n\n    return data;\n}\n\nfunction onRender() {\n    const { containerEl, listEl, state } = this;\n    const { config, items, autoplayInterval, paused, interacting } = state;\n\n    // Do nothing for empty carousels.\n    if (!items.length) {\n        return;\n    }\n\n    // Force a rerender to start the offset override animation.\n    if (config.offsetOverride) {\n        config.offsetOverride = undefined;\n        this.renderFrame = requestAnimationFrame(() => this.setStateDirty());\n        return;\n    }\n\n    // Track if we are on a normal render or a render caused by recalculating.\n    if (config.preserveItems) {\n        config.preserveItems = false;\n\n        // Ensure only visible items within the carousel are focusable.\n        // We don't have access to these items in the template so me must update manually.\n        this.focusFrame = requestAnimationFrame(() => {\n            forEls(listEl, (itemEl) => {\n                focusables(itemEl).forEach(\n                    itemEl.getAttribute(\"aria-hidden\") !== \"true\"\n                        ? // Default the child tabindex to data-carousel-tabindex if it exists, or remove it\n                          (child) =>\n                              child.hasAttribute(\"data-carousel-tabindex\")\n                                  ? child.setAttribute(\n                                        \"tabindex\",\n                                        child.getAttribute(\n                                            \"data-carousel-tabindex\"\n                                        )\n                                    )\n                                  : child.removeAttribute(\"tabindex\")\n                        : (child) => child.setAttribute(\"tabindex\", \"-1\")\n                );\n            });\n        });\n\n        if (config.nativeScrolling) {\n            if (this.skipScrolling) {\n                this.emitUpdate();\n            } else {\n                const offset = getOffset(state);\n                if (offset !== listEl.scrollLeft) {\n                    // Animate to the new scrolling position and emit update events afterward.\n                    config.scrollTransitioning = true;\n                    this.cancelScrollTransition = scrollTransition(\n                        listEl,\n                        offset,\n                        this.emitUpdate\n                    );\n                } else if (this.isMoving) {\n                    // Animate to the new scrolling position and emit update events afterward.\n                    config.scrollTransitioning = true;\n                    this.cancelScrollTransition = scrollTransition(\n                        listEl,\n                        getOffset(state),\n                        this.emitUpdate\n                    );\n                }\n            }\n        }\n\n        if (autoplayInterval && !paused && !interacting) {\n            const moveRight = this.move.bind(this, RIGHT);\n            this.autoplayTimeout = setTimeout(() => {\n                if (this.isMoving) {\n                    return this.once(\"move\", moveRight);\n                }\n                moveRight();\n            }, autoplayInterval);\n        }\n\n        return;\n    }\n\n    // Otherwise recalculates the items / slide sizes.\n    this.renderFrame = requestAnimationFrame(() => {\n        const { width: containerWidth } = containerEl.getBoundingClientRect();\n        const { left: currentLeft } =\n            listEl.firstElementChild.getBoundingClientRect();\n\n        this.setStateDirty(\"slideWidth\", containerWidth);\n        config.preserveItems = true;\n        config.nativeScrolling = isNativeScrolling(listEl);\n\n        // Update item positions in the dom.\n        forEls(listEl, (itemEl, i) => {\n            const item = items[i];\n            const { left, right } = itemEl.getBoundingClientRect();\n            item.left = left - currentLeft;\n            item.right = right - currentLeft;\n        });\n    });\n}\n\n/**\n * Called before updates and before the widget is destroyed to remove any pending async timers / actions.\n */\nfunction cleanupAsync() {\n    clearTimeout(this.autoplayTimeout);\n    cancelAnimationFrame(this.renderFrame);\n    cancelAnimationFrame(this.focusFrame);\n\n    if (this.cancelScrollTransition) {\n        this.cancelScrollTransition();\n        this.cancelScrollTransition = undefined;\n    }\n}\n\nfunction emitUpdate() {\n    const {\n        state: { config, items },\n    } = this;\n    config.scrollTransitioning = false;\n    this.emit(\"move\", {\n        visibleIndexes: items\n            .filter(({ fullyVisible }) => fullyVisible)\n            .map((item) => items.indexOf(item)),\n    });\n}\n\n/**\n * Moves the carousel in the `data-direction` of the clicked element if possible.\n *\n * @param {MouseEvent} originalEvent\n * @param {HTMLElement} target\n */\nfunction handleMove(direction, originalEvent) {\n    if (this.isMoving) {\n        return;\n    }\n    const { state } = this;\n    const nextIndex = this.move(direction);\n    const slide = getSlide(state, nextIndex);\n    this.emit(\"slide\", { slide: slide + 1, originalEvent });\n    this.emit(`${direction === 1 ? \"next\" : \"previous\"}`, { originalEvent });\n}\n\n/**\n * Toggles the play state of an autoplay carousel.\n *\n * @param {MouseEvent} originalEvent\n */\nfunction togglePlay(originalEvent) {\n    const {\n        state: { config, paused },\n    } = this;\n    config.preserveItems = true;\n    this.setState(\"paused\", !paused);\n    if (paused && !this.isMoving) {\n        this.move(RIGHT);\n    }\n    this.emit(`${paused ? \"play\" : \"pause\"}`, { originalEvent });\n}\n\n/**\n * Find the closest item index to the scroll offset and triggers an update.\n *\n * @param {number} scrollLeft The current scroll position of the carousel.\n */\nfunction handleScroll(scrollLeft) {\n    const { state } = this;\n    const { config, items, gap } = state;\n    let closest;\n\n    if (scrollLeft >= getMaxOffset(state) - gap) {\n        closest = items.length - 1;\n    } else {\n        // Find the closest item using a binary search on each carousel slide.\n        const itemsPerSlide = state.itemsPerSlide || 1;\n        const totalItems = items.length;\n        let low = 0;\n        let high = Math.ceil(totalItems / itemsPerSlide) - 1;\n\n        while (high - low > 1) {\n            const mid = Math.floor((low + high) / 2);\n            if (scrollLeft > items[mid * itemsPerSlide].left) {\n                low = mid;\n            } else {\n                high = mid;\n            }\n        }\n\n        const deltaLow = Math.abs(scrollLeft - items[low * itemsPerSlide].left);\n        const deltaHigh = Math.abs(\n            scrollLeft - items[high * itemsPerSlide].left\n        );\n        closest = normalizeIndex(\n            state,\n            (deltaLow > deltaHigh ? high : low) * itemsPerSlide\n        );\n    }\n\n    if (state.index !== closest) {\n        this.skipScrolling = true;\n        config.preserveItems = true;\n        this.setState(\"index\", closest);\n        this.emit(\"scroll\", { index: closest });\n    }\n}\n\nfunction handleStartInteraction() {\n    this.setState(\"interacting\", true);\n}\n\nfunction handleEndInteraction() {\n    this.setState(\"interacting\", false);\n}\n\n/**\n * Causes the carousel to move to the provided index.\n *\n * @param {-1|1} delta 1 for right and -1 for left.\n * @return {number} the updated index.\n */\nfunction move(delta) {\n    const { state } = this;\n    const {\n        index,\n        items,\n        itemsPerSlide,\n        autoplayInterval,\n        slideWidth,\n        gap,\n        peek,\n        config,\n    } = state;\n    const nextIndex = getNextIndex(state, delta);\n    let offsetOverride;\n\n    config.preserveItems = true;\n    this.isMoving = true;\n    this.skipScrolling = false;\n\n    // When we are in autoplay mode we overshoot the desired index to land on a clone\n    // of one of the ends. Then after the transition is over we update to the proper position.\n    if (autoplayInterval) {\n        if (delta === RIGHT && nextIndex < index) {\n            // Transitions to one slide before the beginning.\n            offsetOverride = -slideWidth - gap;\n\n            // Move the items in the last slide to be before the first slide.\n            for (let i = Math.ceil(itemsPerSlide + peek); i--; ) {\n                const item = items[items.length - i - 1];\n                item.transform = `translateX(${\n                    (getMaxOffset(state) + slideWidth + gap) * -1\n                }px)`;\n            }\n        } else if (delta === LEFT && nextIndex > index) {\n            // Transitions one slide past the end.\n            offsetOverride = getMaxOffset(state) + slideWidth + gap;\n\n            // Moves the items in the first slide to be after the last slide.\n            for (let i = Math.ceil(itemsPerSlide + peek); i--; ) {\n                const item = items[i];\n                item.transform = `translateX(${\n                    getMaxOffset(state) + slideWidth + gap\n                }px)`;\n            }\n        }\n\n        config.offsetOverride = offsetOverride;\n    }\n\n    this.setState(\"index\", nextIndex);\n    this.once(\"move\", () => {\n        this.isMoving = false;\n\n        if (offsetOverride !== undefined) {\n            // If we are in autoplay mode and went outside of the normal offset\n            // We make sure to restore all of the items that got moved around.\n            items.forEach((item) => {\n                item.transform = undefined;\n            });\n        }\n    });\n\n    return nextIndex;\n}\n\n/**\n * Given the current widget state, finds the active offset left of the selected item.\n * Also automatically caps the offset at the max offset.\n *\n * @param {object} state The widget state.\n * @return {number}\n */\nfunction getOffset(state) {\n    const { items, index } = state;\n    if (!items.length) {\n        return 0;\n    }\n    return Math.min(items[index].left, getMaxOffset(state)) || 0;\n}\n\n/**\n * Given the current widget state, finds the last valid offset.\n *\n * @param {object} state The widget state.\n * @return {number}\n */\nfunction getMaxOffset({ items, slideWidth }) {\n    if (!items.length) {\n        return 0;\n    }\n    return Math.max(items[items.length - 1].right - slideWidth, 0) || 0;\n}\n\n/**\n * Gets the slide for a given index.\n * Defaults to the current index if none provided.\n *\n * @param {object} state The widget state.\n * @param {number?} i the index to get the slide for.\n * @return {number}\n */\nfunction getSlide({ index, itemsPerSlide }, i = index) {\n    if (!itemsPerSlide) {\n        return;\n    }\n\n    return Math.ceil(i / itemsPerSlide);\n}\n\n/**\n * Ensures that an index is valid.\n *\n * @param {object} state The widget state.\n * @param {number} index the index to normalize.\n */\nfunction normalizeIndex({ items, itemsPerSlide }, index) {\n    if (index > 0) {\n        let result = index;\n        result %= items.length || 1; // Ensure index is within bounds.\n        result -= result % (itemsPerSlide || 1); // Round index to the nearest valid slide index.\n        result = Math.abs(result); // Ensure positive value.\n        return result;\n    }\n\n    return 0;\n}\n\n/**\n * Calculates the next valid index in a direction.\n *\n * @param {object} state The widget state.\n * @param {-1|1} delta 1 for right and -1 for left.\n * @return {number}\n */\nfunction getNextIndex(state, delta) {\n    const { index, items, slideWidth, itemsPerSlide } = state;\n    let i = index;\n    let item;\n\n    // If going backward from 0, we go to the end.\n    if (delta === LEFT && i === 0) {\n        i = items.length - 1;\n    } else {\n        // Find the index of the next item that is not fully in view.\n        do {\n            item = items[(i += delta)];\n        } while (item && item.fullyVisible);\n\n        if (delta === LEFT && !itemsPerSlide) {\n            // If going left without items per slide, go as far left as possible while keeping this item fully in view.\n            const targetOffset = item.right - slideWidth;\n            do {\n                item = items[--i];\n            } while (item && item.left >= targetOffset);\n            i += 1;\n        }\n    }\n\n    return normalizeIndex(state, i);\n}\n\n/**\n * Calls a function on each element within a parent element.\n *\n * @param {HTMLElement} parent The parent to walk through.\n * @param {(el: HTMLElement, i: number) => any} fn The function to call.\n */\nfunction forEls(parent, fn) {\n    let i = 0;\n    let child = parent.firstElementChild;\n    while (child) {\n        fn(child, i++);\n        child = child.nextElementSibling;\n    }\n}\n\n/**\n * Checks if the left/right offset is undefined\n *\n * @param {*} state  The widget state\n * @returns\n */\nfunction isAnimating(state) {\n    const { items, index } = state;\n    if (!items.length) {\n        return false;\n    }\n    const currentItem = items[index];\n    return currentItem.left === undefined || currentItem.right === undefined;\n}\n\n/**\n * Checks if an element is using native scrolling.\n *\n * @param {HTMLElement} el the element to check\n * @return {boolean}\n */\nfunction isNativeScrolling(el) {\n    return getComputedStyle(el).overflowX !== \"visible\";\n}\n\nexport default {\n    getTemplateData,\n    move,\n    handleMove,\n    handleStartInteraction,\n    handleEndInteraction,\n    togglePlay,\n\n    onInput(input) {\n        const gap = parseInt(input.gap, 10);\n        const state = {\n            htmlAttributes: processHtmlAttributes(input, [\n                \"class\",\n                \"style\",\n                \"index\",\n                \"type\",\n                \"slide\",\n                \"gap\",\n                \"autoplay\",\n                \"paused\",\n                \"itemsPerSlide\",\n                \"a11yPreviousText\",\n                \"a11yNextText\",\n                \"a11yPlayText\",\n                \"a11yPauseText\",\n                \"items\",\n                \"hiddenScrollbar\",\n            ]),\n            classes: [\n                \"carousel\",\n                input.hiddenScrollbar && \"carousel--hidden-scrollbar\",\n                input.class,\n            ],\n            style: input.style,\n            config: {}, // A place to store values that should not trigger an update by themselves.\n            gap: isNaN(gap) ? 16 : gap,\n            index: parseInt(input.index, 10) || 0,\n            itemsPerSlide: parseFloat(input.itemsPerSlide, 10) || undefined,\n            a11yPreviousText: input.a11yPreviousText || \"Previous Slide\",\n            a11yNextText: input.a11yNextText || \"Next Slide\",\n            a11yPauseText: input.a11yPauseText || \"Pause\",\n            a11yPlayText: input.a11yPlayText || \"Play\",\n            ariaRoleDescription: input[\"aria-roledescription\"] || \"Carousel\",\n        };\n\n        const itemSkippedAttributes = [\"class\", \"style\", \"key\"];\n        const { itemsPerSlide } = state;\n        if (itemsPerSlide) {\n            state.peek = itemsPerSlide % 1;\n            state.itemsPerSlide = itemsPerSlide - state.peek;\n            state.classes.push(\"carousel--slides\");\n\n            if (!state.peek && !input.autoplay && !input.noPeek) {\n                state.peek = 0.1;\n            }\n\n            if (state.peek) {\n                state.classes.push(\"carousel--peek\");\n            }\n\n            // Only allow autoplay option for discrete carousels.\n            if (input.autoplay) {\n                const isSingleSlide = input.items.length <= itemsPerSlide;\n                state.autoplayInterval = parseInt(input.autoplay, 10) || 4000;\n                state.classes.push(\"carousel__autoplay\");\n                state.paused = isSingleSlide || input.paused; // Force paused state if not enough slides provided;\n                state.interacting = false;\n            }\n        }\n\n        state.items = (input.items || []).map((item, i) => {\n            const isStartOfSlide = state.itemsPerSlide\n                ? i % state.itemsPerSlide === 0\n                : true;\n            return {\n                htmlAttributes: processHtmlAttributes(\n                    item,\n                    itemSkippedAttributes\n                ),\n                class: isStartOfSlide\n                    ? [\"carousel__snap-point\", item.class]\n                    : item.class,\n                key: item.key || i,\n                style: item.style,\n                renderBody: item.renderBody,\n            };\n        });\n\n        this.skipScrolling = false;\n        this.state = state;\n    },\n\n    onRender() {\n        if (typeof window !== \"undefined\") {\n            cleanupAsync.call(this);\n        }\n    },\n\n    onMount() {\n        const {\n            state: { config },\n        } = this;\n        this.listEl = this.getEl(\"list\");\n        this.nextEl = this.getEl(\"next\");\n        this.containerEl = this.getEl(\"container\");\n        this.emitUpdate = emitUpdate.bind(this);\n        this.subscribeTo(resizeUtil).on(\"resize\", () => {\n            cleanupAsync.call(this);\n            onRender.call(this);\n        });\n        this.skipScrolling = false;\n\n        if (isNativeScrolling(this.listEl)) {\n            config.nativeScrolling = true;\n            this.once(\n                \"destroy\",\n                onScroll(this.listEl, () => {\n                    if (!config.scrollTransitioning) {\n                        handleScroll.call(this, this.listEl.scrollLeft);\n                    }\n                })\n            );\n        } else {\n            this.subscribeTo(this.listEl).on(\"transitionend\", ({ target }) => {\n                if (target === this.listEl) {\n                    this.emitUpdate();\n                }\n            });\n        }\n\n        this.onRenderLegacy({\n            firstRender: true,\n        });\n    },\n\n    onUpdate() {\n        this.onRenderLegacy({\n            firstRender: false,\n        });\n    },\n\n    onDestroy() {\n        cleanupAsync.call(this);\n    },\n\n    onRenderLegacy() {\n        onRender.call(this);\n    },\n};\n","$ var data = component.getTemplateData(state, input);\n$ var config = data.config;\n\n<div\n    ...data.htmlAttributes\n    class=data.classes\n    style=data.style\n    aria-roledescription=data.ariaRoleDescription\n    role='group'\n>\n    <div\n        class=[\n            'carousel__container',\n            data.bothControlsDisabled && 'carousel__container--controls-disabled',\n        ]\n        onFocusin(data.autoplayInterval && 'handleStartInteraction')\n        onTouchstart(data.autoplayInterval && 'handleStartInteraction')\n        onMouseover(data.autoplayInterval && 'handleStartInteraction')\n        onFocusout(data.autoplayInterval && 'handleEndInteraction')\n        onMouseout(data.autoplayInterval && 'handleEndInteraction')\n        onTouchend(data.autoplayInterval && 'handleEndInteraction')\n        key='container'\n        id:scoped='container'\n    >\n        <button\n            class=['carousel__control', 'carousel__control--prev']\n            type='button'\n            on-click(!data.prevControlDisabled && 'handleMove', -1)\n            aria-label=data.a11yPreviousText\n            aria-disabled=data.prevControlDisabled && 'true'\n        >\n            <ebay-chevron-left-12-icon/>\n        </button>\n        <div class=[\n            'carousel__viewport',\n            !data.itemsPerSlide &&\n                !data.nextControlDisabled &&\n                !data.autoplayInterval &&\n                'carousel__viewport--mask',\n        ]>\n            <ul\n                class=[\n                    'carousel__list',\n                    input.imageTreatment === 'matte' && 'carousel__list--image-treatment',\n                ]\n                style=!config.nativeScrolling &&\n                data.offset && {\n                    transform: 'translate3d(' + data.offset * -1 + 'px,0,0)',\n                    transition: data.disableTransition ? 'none' : undefined,\n                }\n                key='list'\n                id:scoped='list'\n            >\n                <for|item| of=data.items>\n                    <li\n                        ...item.htmlAttributes\n                        key=item.key\n                        class=item.class\n                        style=item.style\n                        aria-hidden=!item.fullyVisible && 'true'\n                        no-update-body-if(!!config.preserveItems)\n                    >\n                        <${item.renderBody}/>\n                    </li>\n                </for>\n            </ul>\n        </div>\n        <button\n            class=['carousel__control', 'carousel__control--next']\n            type='button'\n            on-click(!data.nextControlDisabled && 'handleMove', 1)\n            aria-label=data.a11yNextText\n            aria-disabled=data.nextControlDisabled && 'true'\n            key='next'\n            id:scoped='next'\n        >\n            <ebay-chevron-right-12-icon/>\n        </button>\n        <if(data.autoplayInterval && !data.bothControlsDisabled)>\n            <button.carousel__playback\n                type='button'\n                aria-label=(data.paused ? data.a11yPlayText : data.a11yPauseText)\n                onClick('togglePlay')\n            >\n                <if(data.paused)>\n                    <ebay-play-24-icon/>\n                </if>\n                <else><ebay-pause-24-icon/></else>\n            </button>\n        </if>\n    </div>\n</div>\n","export default \"<h1 style=\\\"display: flex; justify-content: space-between; align-items: center;\\\">\\n    <span>\\n        ebay-carousel\\n    </span>\\n    <span style=\\\"font-weight: normal; font-size: medium; margin-bottom: -15px;\\\">\\n        DS v1.1.0\\n    </span>\\n</h1>\\n\\nDescrete or Continuious carousel component. Can show items as a slide or various widths.\\n\\n## Examples and Documentation\\n\\n-   [Storybook](https://ebay.github.io/ebayui-core/?path=/story/navigation-disclosure-ebay-carousel)\\n-   [Storybook Docs](https://ebay.github.io/ebayui-core/?path=/docs/navigation-disclosure-ebay-carousel)\\n-   [Code Examples](https://github.com/eBay/ebayui-core/tree/master/src/components/ebay-carousel/examples)\\n\\n## Preserving tabindex for focusable elements\\n\\nWhen scrolling items, focusable elements that are not visible in the carousel should not be tabbable by default. When the carousel scrolls, it then removes the tabindex to allow the item to be focusable.\\nIn order to preserve the tabindex on an item, pass `data-carousel-tabindex=\\\"-1\\\"` attribute to a given focusable element in order to default to that tabindex instead of removing the tabindex when the item is visible.\\n\"","<style>\n    .preserve-tabindex-card {\n        color: #cdf4fd;\n        background: #eee;\n        font-size: 36px;\n        font-weight: bold;\n        height: 330px;\n        text-align: center;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n    }\n</style>\n\n<ebay-carousel gap=input.gap items-per-slide=input.itemsPerSlide index=input.index\n    a11y-previous-text=input.a11yPreviousText\n    a11y-next-text=input.a11yNextText>\n    <for|i| from=0 to=(input.items.length - 1)>\n        <@item >\n            <div class='preserve-tabindex-card'>\n                <a href=\"https://www.ebay.com\" data-carousel-tabindex=\"-1\">\n                    Image here\n                </a>\n                <a href=\"https://www.ebay.com\">\n                    <${input.items[i]}/>\n                </a>\n                <ebay-drawer-dialog open=true>\n                    Body\n                </ebay-drawer-dialog>\n\n            </div>\n        </@item>\n    </for>\n</ebay-carousel>\n","export default \"<style>\\n    .preserve-tabindex-card {\\n        color: #cdf4fd;\\n        background: #eee;\\n        font-size: 36px;\\n        font-weight: bold;\\n        height: 330px;\\n        text-align: center;\\n        display: flex;\\n        flex-direction: column;\\n        justify-content: center;\\n    }\\n</style>\\n\\n<ebay-carousel gap=input.gap items-per-slide=input.itemsPerSlide index=input.index\\n    a11y-previous-text=input.a11yPreviousText\\n    a11y-next-text=input.a11yNextText>\\n    <for|i| from=0 to=(input.items.length - 1)>\\n        <@item >\\n            <div class='preserve-tabindex-card'>\\n                <a href=\\\"https://www.ebay.com\\\" data-carousel-tabindex=\\\"-1\\\">\\n                    Image here\\n                </a>\\n                <a href=\\\"https://www.ebay.com\\\">\\n                    <${input.items[i]}/>\\n                </a>\\n                <ebay-drawer-dialog open=true>\\n                    Body\\n                </ebay-drawer-dialog>\\n\\n            </div>\\n        </@item>\\n    </for>\\n</ebay-carousel>\\n\""],"names":["eventOptions","onScrollDebounced","el","cb","timeout","waitForScroll","cancel","handleScroll","cancelWaitForScroll","finish","onScrollEnd","fn","frame","lastPos","checkMoved","scrollLeft","supportsScrollBehavior","scrollTransition","to","lastPosition","cancelInterruptTransition","startTime","distance","duration","animate","curTime","delta","easeInOut","handleTouchStart","cancelTouchStart","cancelTouchEnd","handleTouchEnd","v","LEFT","RIGHT","getTemplateData","state","config","autoplayInterval","items","itemsPerSlide","slideWidth","gap","hasOverride","isSingleSlide","normalizeIndex","offset","getOffset","prevControlDisabled","nextControlDisabled","getMaxOffset","bothControlsDisabled","isAnimating","slide","itemWidth","totalSlides","itemsInSlide","getSlide","item","i","style","transform","marginRight","onRender","containerEl","listEl","paused","interacting","forEls","itemEl","focusables","child","moveRight","containerWidth","currentLeft","isNativeScrolling","left","right","cleanupAsync","emitUpdate","fullyVisible","handleMove","direction","originalEvent","nextIndex","togglePlay","closest","totalItems","low","high","mid","deltaLow","deltaHigh","handleStartInteraction","handleEndInteraction","move","index","peek","getNextIndex","offsetOverride","result","targetOffset","parent","currentItem","_marko_component$1","input","processHtmlAttributes","itemSkippedAttributes","isStartOfSlide","resizeUtil","onScroll","target","data","_component","out","be","_marko_merge_attrs","htmlAttributes","_marko_class_merge","classes","_marko_style_merge","ariaRoleDescription","_componentDef","elId","d","a11yPreviousText","_marko_tag","_ebayChevronLeft12Icon","ee","imageTreatment","nativeScrolling","transition","disableTransition","undefined","_keyValue","concat","key","_keyScope","class","_preserve","preserveItems","_marko_dynamic_tag","renderBody","a11yNextText","_ebayChevronRight12Icon","a11yPlayText","a11yPauseText","_ebayPlay24Icon","_ebayPause24Icon","t","_marko_componentType","_marko_component2","_marko_template","Component","_marko_defineComponent","_","Readme","_marko_node","_marko_createElement","_marko_registerComponent","_marko_component","_marko_renderer","$global","n","_items","_steps","length","_step","push","_ebayDrawerDialog","Symbol","iterator","_marko_self_iterator","_ebayCarousel","defaultTabIndexCode"],"mappings":"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"}